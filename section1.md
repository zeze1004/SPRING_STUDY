# 객체 지향 설계와 스프링

*스프링을 이해하기 위해서는 `다형성`과 `SOLID`를 이해해야 함!*



## 1. 스프링이란

##### [필수]

- 스프링 프레임워크(핵심)
- 스프링 부트(많은 기능들을 편하게 쓸 수 있도록 도와줌)
- Tomcat 같은 웹 서버 내장해서 별도의 웹 서버를 설치하지 않아도 됨
- 손쉬운 빌드 구성을 위한 starter 종속성 제공, 종속 라이브러리 자동으로 다운

##### [선택]

- 스프링 데이터, 세션, 시큐리티, 클라우드 등등

### 스프링 단어

- 스프링 단어는 문맥에 따라 다르게 사용
- 스프링 DI 컨테이너 기술
- 스프링 프레임워크
- 스프링 부트, 프레임워크 등을 모두 포함한 스프링 생태계

### 스프링 핵심 컨셉

- 객체 지향 언어 기반 프레임워크의 장점을 최대한 살려 **좋은 객체 지향 애플리케이션** 개발할 수 있게 도와줌



### 좋은 객체 지향이란

- 객체들의 모임이며 각각의 객체는 메세지를 주고 받고 데이터 처리할 수 있음

- 객체 지향 프로그래밍은 프로그램을 **유연**하고 **변경**이 용이하게 만들어 대규모 소프트웨어 개발에 적합

  ## 1. 다형성(Poly)

  #### 역할(인터페이스)과 구현(인터페이스 구현한 클래스, 구현 객체)을 분리

  - 객체 설계시 역할(인터페이스)먼저 부여,

    그 역할을 수행하는 구현 객체 만들기

  ##### 다형성을 현실 세계와 비교

  - 운전자 - 자동차

    ![image-20210302165102940](C:\Project\SPRING_STUDY\다형성.png)

    - 클라이언트는 대상의 역할(인터페이스)만 알면 된다.
    - 클라이언트 구현 대상의 내부 구조를 몰라도 된다.
    - 클라이언트 구현 대상의 내부 구조가 변경 되어도 영향x
    - 클라이언트는 구현 대상 자체를 변경해도 영향x

    			#### 객체는 협력 관계

    - 혼자 있는 객체는 없음
    - 클라이언트: **요청**, 서버: **응답**(클라이언트의 요청을 해결한 것)
    - 객체 클라이언트와 객체 서버는 서로 협력 관계 가짐

    

    ## 2. SOLID

    |  S   | SRP  | 단일 책임 원칙 (Single responsibility principle) "한 [클래스](https://ko.wikipedia.org/wiki/클래스_(컴퓨터_과학))는 하나의 책임만 가져야 한다." |
    | :--: | ---- | ------------------------------------------------------------ |
    |  O   | OCP  | **개방-폐쇄 원칙** “소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.” |
    |  L   | LSP  | [리스코프 치환 원칙 (Liskov substitution principle)](https://ko.wikipedia.org/wiki/리스코프_치환_원칙)“프로그램의 [객체](https://ko.wikipedia.org/wiki/객체)는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.” [계약에 의한 설계](https://ko.wikipedia.org/w/index.php?title=계약에_의한_설계&action=edit&redlink=1)를 참고하라. |
    |  I   | ISP  | [인터페이스 분리 원칙 (Interface segregation principle)](https://ko.wikipedia.org/wiki/인터페이스_분리_원칙)“특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.”[[4\]](https://ko.wikipedia.org/wiki/SOLID_(객체_지향_설계)#cite_note-martin-design-principles-4) |
    |  D   | DIP  | [의존관계 역전 원칙 (Dependency inversion principle)](https://ko.wikipedia.org/wiki/의존관계_역전_원칙)프로그래머는 “추상화에 의존해야지, 구체화에 의존하면 안된다.”[[4\]](https://ko.wikipedia.org/wiki/SOLID_(객체_지향_설계)#cite_note-martin-design-principles-4) [의존성 주입](https://ko.wikipedia.org/wiki/의존성_주입)은 이 원칙을 따르는 방법 중 하나다. |

  1. SRP

     - `하나의 책임`은 모호함

     - 중요한 기준은 **변경**(SRP를 잘 했는지 판단의 기준)

       변경이 있을 시 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것

  2. OCP⭐

     - 변경시 기존 코드를 변경할 것이 아니라,

       인터페이스를 구현한 새로운 클래스를 하나 만들어 새로운 기능 구현(**다형성** 활용)

     - ##### OCP 문제점

       ???

  3. LSP

     - 자동차 인터페이스의 엑셀은 앞으로 가는 기능, 뒤로 가게 구현 시 LSP 위반

       컴파일에 성공하더라도 계약에 의한 기능을 보장해야 함

  4. ISP

     - 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리

       사용자 인터페이스 -> 운전자 클라이언트, 정비사 클라이언트로 분리

       분리 시, 정비 인터페이스가 변해도 운전자 클라이언트에 영향X

     - 인터페이스 명확해지고 대체 가능성 높아짐

  5. DIP⭐

     - 구현 클래스에 의존 X, 인터페이스에 의존 O

       클라이언트 코드가 구현 코드(기능)를 보지 말고 인터페이스(역할)만 바라봐야 함

       => 역할과 구현을 철저히 분리해서 클라이언트가 인터페이스에 의존하게 해야 함

     - ##### DIP 문제점

       객체 지향의 핵심은 **다향성**

       BUT, 다형성 만으로는 SOLID 원칙을 지키면서 조립하듯이 개발할 수 없음

       => 다향성 만으로는 구현 객체 변경시 클라이언트 코드도 변경





## 2. 객체 지향 설계와 스프링

*스프링 이야기에 왜 객체 지향 이야기가 나오는가?*

앞서 OCP, DIP의 문제점 언급, 다향성만으로 SOLID 원칙 지킬 수 X

- `DI`: 의존관계, 의존성 주입

  `DI 컨테이너` 제공

- 클라이언트의 코드 변경 없이 기능 확장 가능

- 스프링의 제어의 역전(IoC), 의존관계 주입(DI)은 다향성을 활용해 역할과 구현을 편리하게 다룰 수 있도록 지원



##### 실무 고민

- 다양한 인터페이스 구현하면 추상화라는 비용 발생

  기능 확장 가능성이 없다면, 인테페이스 도입 X 구체 클래스 직접 사용 





